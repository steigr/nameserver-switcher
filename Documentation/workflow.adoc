= Workflow and Operation Modes
:toc: left
:toclevels: 3
:numbered:
:icons: font
:source-highlighter: rouge

== Router Decision Logic

The nameserver-switcher router implements an intelligent decision tree to determine which DNS resolver to use for each query.

=== Decision Flow

[source]
----
                    ┌──────────────────────┐
                    │   DNS Query Arrives  │
                    └──────────┬───────────┘
                               ▼
                    ┌──────────────────────┐
                    │ Extract Query Name   │
                    │ (strip trailing .)   │
                    └──────────┬───────────┘
                               ▼
                    ┌──────────────────────┐
                    │ Match against        │
                    │ REQUEST_PATTERNS?    │
                    └──────────┬───────────┘
                               ▼
                ┌──────────────┴──────────────┐
                │                             │
              NO│                             │YES
                ▼                             ▼
    ┌────────────────────┐      ┌────────────────────────┐
    │ Use Passthrough    │      │ Query Explicit         │
    │ Resolver           │      │ Resolver               │
    │ (PASSTHROUGH_      │      │ (Non-recursive)        │
    │  RESOLVER)         │      └─────────┬──────────────┘
    └────────────────────┘                ▼
                              ┌────────────────────────┐
                              │ Response has CNAME?    │
                              └─────────┬──────────────┘
                                        ▼
                            ┌───────────┴───────────┐
                            │                       │
                          NO│                       │YES
                            ▼                       ▼
                ┌────────────────────┐   ┌────────────────────┐
                │ Use No-CNAME-      │   │ Extract CNAME      │
                │ Response Resolver  │   │ Target             │
                │ (NO_CNAME_RESPONSE_│   └─────────┬──────────┘
                │  RESOLVER)         │             ▼
                └────────────────────┘   ┌────────────────────┐
                                         │ Match CNAME against│
                                         │ CNAME_PATTERNS?    │
                                         └─────────┬──────────┘
                                                   ▼
                                       ┌───────────┴───────────┐
                                       │                       │
                                     NO│                       │YES
                                       ▼                       ▼
                           ┌────────────────────┐   ┌────────────────────┐
                           │ Use No-CNAME-Match │   │ Return Response    │
                           │ Resolver           │   │ from Explicit      │
                           │ (NO_CNAME_MATCH_   │   │ Resolver           │
                           │  RESOLVER)         │   │ (Recursive)        │
                           └────────────────────┘   └────────────────────┘
----

NOTE: Each fallback resolver is independently configurable. If not configured, they fall back to the system resolver (REQUEST_RESOLVER or /etc/resolv.conf).

=== Routing Modes

nameserver-switcher operates in different modes depending on the pattern matching results.

==== Mode Comparison Table

[cols="2,3,3,3,3", options="header"]
|===
|Mode
|Request Pattern Match
|CNAME in Response
|CNAME Pattern Match
|Resolver Used

|**Passthrough**
|❌ No Match
|N/A
|N/A
|Passthrough Resolver (PASSTHROUGH_RESOLVER)

|**No CNAME Response**
|✅ Match
|❌ No CNAME
|N/A
|No-CNAME-Response Resolver (NO_CNAME_RESPONSE_RESOLVER)

|**Explicit Recursive**
|✅ Match
|✅ CNAME Present
|✅ CNAME Matches
|Explicit Resolver (EXPLICIT_RESOLVER)

|**No CNAME Match**
|✅ Match
|✅ CNAME Present
|❌ CNAME No Match
|No-CNAME-Match Resolver (NO_CNAME_MATCH_RESOLVER)

|===

NOTE: If specific resolvers are not configured, they fall back to the system resolver (REQUEST_RESOLVER or /etc/resolv.conf).

=== Detailed Mode Descriptions

==== Mode 1: Passthrough

**Trigger:** Request does not match any REQUEST_PATTERNS

**Resolver:** PASSTHROUGH_RESOLVER (falls back to REQUEST_RESOLVER or system resolver)

**Behavior:**

* Immediately routes query to passthrough resolver
* Full recursive resolution performed by passthrough resolver
* No pattern matching overhead
* Standard DNS resolution

**Example:**

[source]
----
Query: unmatched-domain.com
Request Pattern: ".*\.example\.com$"

Result:
  ✗ No REQUEST_PATTERN match
  → Use Passthrough Resolver
  → Returns: unmatched-domain.com A 1.2.3.4
----

**Use Case:** Default behavior for queries outside configured patterns (e.g., general internet domains)

==== Mode 2: No CNAME Response

**Trigger:** Request matches REQUEST_PATTERNS but response from explicit resolver contains no CNAME

**Resolver:** NO_CNAME_RESPONSE_RESOLVER (falls back to REQUEST_RESOLVER or system resolver)

**Behavior:**

* Queries explicit resolver (first)
* Response contains direct A/AAAA records (no CNAME)
* **Falls back to no-cname-response resolver** for the actual response
* CNAME pattern checking not applicable (no CNAME present)

**Example:**

[source]
----
Query: direct.example.com
Request Pattern: ".*\.example\.com$"
Explicit Resolver Response: direct.example.com A 10.0.0.1 (has no CNAME)

Result:
  ✓ REQUEST_PATTERN matches
  → Query Explicit Resolver (first check)
  ✗ No CNAME in response
  → Fallback to No-CNAME-Response Resolver
  → Returns: response from no-cname-response resolver
----

**Use Case:** Queries that match request patterns but don't have CNAMEs - dedicated resolver handles resolution

==== Mode 3: Explicit Recursive

**Trigger:** Request matches REQUEST_PATTERNS, response has CNAME, and CNAME matches CNAME_PATTERNS

**Behavior:**

* Queries explicit resolver (non-recursive first)
* Response contains CNAME record
* CNAME target matches CNAME pattern
* Returns explicit resolver's full recursive response
* This is the "happy path" for CNAME-based routing

**Example:**

[source]
----
Query: app.example.com
Request Pattern: ".*\.example\.com$"
CNAME Pattern: ".*-prod\.cdn\.example\.com$"
Explicit Resolver Response:
  app.example.com CNAME app-prod.cdn.example.com
  app-prod.cdn.example.com A 10.20.30.40

Result:
  ✓ REQUEST_PATTERN matches: ".*\.example\.com$"
  → Query Explicit Resolver
  ✓ CNAME present: "app-prod.cdn.example.com"
  ✓ CNAME_PATTERN matches: ".*-prod\.cdn\.example\.com$"
  → Return explicit resolver response (recursive)
  → Returns:
      app.example.com CNAME app-prod.cdn.example.com
      app-prod.cdn.example.com A 10.20.30.40
----

**Use Case:** CDN-backed services, load-balanced endpoints, or services with CNAME records pointing to specific infrastructure

==== Mode 4: No CNAME Match

**Trigger:** Request matches REQUEST_PATTERNS, response has CNAME, but CNAME does NOT match CNAME_PATTERNS

**Resolver:** NO_CNAME_MATCH_RESOLVER (falls back to REQUEST_RESOLVER or system resolver)

**Behavior:**

* Queries explicit resolver initially
* Response contains CNAME record
* CNAME target does NOT match CNAME pattern
* Falls back to no-cname-match resolver for recursive resolution
* No-cname-match resolver handles the full query

**Example:**

[source]
----
Query: external.example.com
Request Pattern: ".*\.example\.com$"
CNAME Pattern: ".*-prod\.cdn\.example\.com$"
Explicit Resolver Response:
  external.example.com CNAME service.external-provider.com

Result:
  ✓ REQUEST_PATTERN matches: ".*\.example\.com$"
  → Query Explicit Resolver
  ✓ CNAME present: "service.external-provider.com"
  ✗ CNAME_PATTERN no match (not .*-prod\.cdn\.example\.com$)
  → Fallback to No-CNAME-Match Resolver
  → No-cname-match resolver recursively resolves service.external-provider.com
  → Returns:
      external.example.com CNAME service.external-provider.com
      service.external-provider.com A 203.0.113.50
----

**Use Case:** Services in matched domains that point to external infrastructure (e.g., third-party CDNs, external services)

== Operation Modes (Protocol)

nameserver-switcher can operate in different protocol modes for integration with CoreDNS.

=== DNS Mode

**Protocol:** DNS over UDP/TCP (RFC 1035)

**Port:** 5353 (default)

**Integration:** CoreDNS `forward` plugin

**Configuration:**

.CoreDNS Corefile
[source,corefile]
----
.:53 {
    forward . nameserver-switcher:5353
    log
    errors
    cache 30
}
----

**Characteristics:**

* Standard DNS protocol
* Works with any DNS client
* Simple to configure and debug
* UDP for most queries, TCP for large responses
* No additional dependencies

**Best For:**

* Simple deployments
* Compatibility with all DNS tools
* When gRPC overhead is unnecessary

=== gRPC Mode

**Protocol:** gRPC over HTTP/2

**Port:** 5354 (default)

**Integration:** CoreDNS `grpc` plugin

**Configuration:**

.CoreDNS Corefile
[source,corefile]
----
.:53 {
    grpc . nameserver-switcher:5354
    log
    errors
    cache 30
}
----

**Characteristics:**

* HTTP/2 multiplexing
* Binary protocol (protobuf)
* Better error handling
* Streaming capabilities
* More efficient for high-volume scenarios

**Best For:**

* High-traffic environments
* Modern infrastructure
* When advanced features are needed
* Microservices architectures

=== Comparison Table

[cols="2,3,3", options="header"]
|===
|Feature
|DNS Mode
|gRPC Mode

|**Protocol**
|DNS (UDP/TCP)
|gRPC (HTTP/2)

|**Port**
|5353
|5354

|**CoreDNS Plugin**
|`forward`
|`grpc`

|**Setup Complexity**
|Simple
|Moderate

|**Performance**
|Good
|Excellent (HTTP/2 multiplexing)

|**Debugging**
|Easy (`dig`, `nslookup`)
|Moderate (requires gRPC tools)

|**Connection Overhead**
|Low (UDP), Medium (TCP)
|Low (connection reuse)

|**Binary Protocol**
|DNS Wire Format
|Protocol Buffers

|**Streaming**
|No
|Yes (potential)

|**Error Details**
|Limited (DNS RCODE)
|Rich (gRPC status codes)

|**Configuration Updates**
|Restart required
|Potential for dynamic updates

|===

== Configuration Scenarios

=== Scenario 1: Split-Horizon DNS

**Objective:** Route internal domains to internal DNS, external to public DNS

**Configuration:**

[source,bash]
----
# Match internal domain patterns
REQUEST_PATTERNS=".*\.internal\.company\.com$
.*\.svc\.cluster\.local$"

# Match internal CDN CNAMEs
CNAME_PATTERNS=".*\.internal-cdn\.company\.com$"

# Use internal DNS for matched patterns
EXPLICIT_RESOLVER="10.0.0.10:53"

# Use public DNS (8.8.8.8) as system resolver
----

**Workflow:**

* `app.internal.company.com` → Explicit Resolver → Internal DNS
* `service.svc.cluster.local` → Explicit Resolver → Kubernetes DNS
* `google.com` → System Resolver → 8.8.8.8

=== Scenario 2: CDN Optimization

**Objective:** Route CDN-backed services to specific resolver for better geo-routing

**Configuration:**

[source,bash]
----
# Match application domains
REQUEST_PATTERNS=".*\.myapp\.com$"

# Match CDN CNAMEs
CNAME_PATTERNS=".*\.cdn\.provider\.net$
.*\.cloudfront\.net$"

# Use CDN-optimized DNS resolver
EXPLICIT_RESOLVER="cdns.myapp.com:53"
----

**Workflow:**

* Query: `www.myapp.com`
* Explicit resolver returns: `www.myapp.com CNAME xyz.cdn.provider.net`
* CNAME matches pattern → Use explicit resolver
* Better CDN routing based on resolver location

=== Scenario 3: Multi-Cloud DNS

**Objective:** Route queries to cloud-specific DNS based on patterns

**Configuration:**

[source,bash]
----
# Match AWS-hosted services
REQUEST_PATTERNS=".*\.aws\.company\.com$"

# Match AWS load balancer CNAMEs
CNAME_PATTERNS=".*\.elb\.amazonaws\.com$
.*\.cloudfront\.net$"

# Use AWS Route53 resolver
EXPLICIT_RESOLVER="169.254.169.253:53"
----

**Workflow:**

* `api.aws.company.com` → AWS Route53 → Optimal AWS routing
* `web.company.com` → System Resolver → Regular DNS

=== Scenario 4: Kubernetes Service Discovery

**Objective:** Route Kubernetes service discovery to cluster DNS while external queries go to corporate DNS

**Configuration:**

[source,bash]
----
# Match Kubernetes internal domains
REQUEST_PATTERNS=".*\.svc\.cluster\.local$
.*\.pod\.cluster\.local$"

# Match Kubernetes service CNAMEs
CNAME_PATTERNS=".*\.svc\.cluster\.local$"

# Use CoreDNS for Kubernetes resolution
EXPLICIT_RESOLVER="kube-dns.kube-system.svc.cluster.local:53"
----

**Workflow:**

* `myservice.default.svc.cluster.local` → Kubernetes DNS → Pod IPs
* `external-api.company.com` → System Resolver → Corporate DNS

=== Scenario 5: Azure SQL Failover Groups (Auto-Connectivity Mode)

**Objective:** Intelligently route Azure SQL Failover Group connections based on regional proximity using private endpoints.

Azure SQL Failover Groups use a DNS-based routing mechanism. When connecting to a failover group endpoint (e.g., `myfailovergroup.database.windows.net`), Azure DNS returns a CNAME pointing to the current primary server. The server name includes the region (e.g., `myserver-westeurope.database.windows.net` or `myserver-northeurope.database.windows.net`).

In auto-connectivity mode with private endpoints:

* **Same-region server**: Use Azure's default DNS to get the redirect IP (public routing optimization)
* **Cross-region server**: Use private DNS zone to resolve the private endpoint address

**Architecture:**

[source]
----
Application in West Europe
           │
           ▼
┌─────────────────────────────────────┐
│  myfailovergroup.database.windows.net │
└─────────────────────────────────────┘
           │
           ▼ (DNS CNAME)
    ┌──────┴──────┐
    │             │
    ▼             ▼
Primary in     Secondary in
West Europe    North Europe
    │             │
    ▼             ▼
CNAME:         CNAME:
myserver-      myserver-
westeurope.    northeurope.
database.      database.
windows.net    windows.net
    │             │
    ▼             ▼
Azure DNS      Private DNS
(Redirect IP)  (Private EP)
----

**Configuration:**

[source,bash]
----
# Match Azure SQL failover group patterns
REQUEST_PATTERNS=".*\.database\.windows\.net$"

# Match servers in the LOCAL region (West Europe in this example)
# These should use Azure DNS for redirect IP optimization
CNAME_PATTERNS=".*-westeurope\.database\.windows\.net$"

# Use Private DNS Zone resolver for cross-region (private endpoint resolution)
# This is the SYSTEM resolver - used when CNAME doesn't match local region
# Points to Azure Private DNS Zone linked to VNet
# System resolver (default): Azure VNet DNS (168.63.129.16) or custom DNS

# Use Azure public DNS for local region servers
# Explicit resolver returns redirect IPs for geo-optimized routing
EXPLICIT_RESOLVER="168.63.129.16:53"
----

**Workflow Example 1 - Primary in Same Region (West Europe):**

[source]
----
Query: myfailovergroup.database.windows.net
Application Region: West Europe
Current Primary: West Europe

Step 1: REQUEST_PATTERN ".*\.database\.windows\.net$" matches
        → Query Explicit Resolver (Azure DNS)

Step 2: Explicit Resolver returns:
        myfailovergroup.database.windows.net CNAME myserver-westeurope.database.windows.net

Step 3: CNAME_PATTERN ".*-westeurope\.database\.windows\.net$" matches
        → Use Explicit Resolver response

Step 4: Returns Azure redirect IP for optimized local routing
        → Application connects via Azure backbone (low latency)
----

**Workflow Example 2 - Primary in Different Region (Failover to North Europe):**

[source]
----
Query: myfailovergroup.database.windows.net
Application Region: West Europe
Current Primary: North Europe (after failover)

Step 1: REQUEST_PATTERN ".*\.database\.windows\.net$" matches
        → Query Explicit Resolver (Azure DNS)

Step 2: Explicit Resolver returns:
        myfailovergroup.database.windows.net CNAME myserver-northeurope.database.windows.net

Step 3: CNAME_PATTERN ".*-westeurope\.database\.windows\.net$" does NOT match
        (Server is in North Europe, not West Europe)
        → Fallback to System Resolver (Private DNS Zone)

Step 4: System Resolver (Private DNS Zone) returns:
        myserver-northeurope.database.windows.net A 10.1.2.3 (Private Endpoint IP)
        → Application connects via private endpoint (secure, no public internet)
----

**Benefits:**

* **Local region traffic**: Uses Azure's optimized redirect IP for best performance
* **Cross-region traffic**: Uses private endpoints for security and reliability
* **Automatic failover handling**: No application changes needed when primary changes
* **Cost optimization**: Local traffic uses Azure backbone, cross-region uses private link

**Multi-Region Deployment:**

For applications deployed in multiple regions, configure each region with its own pattern:

.West Europe Application
[source,bash]
----
REQUEST_PATTERNS=".*\.database\.windows\.net$"
CNAME_PATTERNS=".*-westeurope\.database\.windows\.net$"
EXPLICIT_RESOLVER="168.63.129.16:53"
----

.North Europe Application
[source,bash]
----
REQUEST_PATTERNS=".*\.database\.windows\.net$"
CNAME_PATTERNS=".*-northeurope\.database\.windows\.net$"
EXPLICIT_RESOLVER="168.63.129.16:53"
----

**Note:** The system resolver should be configured to resolve private endpoints via Azure Private DNS Zones linked to your VNet.

== Metrics and Observability

The router tracks detailed metrics for each mode:

* **Request Pattern Matches**: Counter per pattern
* **CNAME Pattern Matches**: Counter per CNAME pattern
* **Resolver Usage**: Counter per resolver (explicit/system)
* **Query Duration**: Histogram by resolver
* **Routing Decisions**: Track which path was taken

See link:monitoring.adoc[Monitoring Documentation] for complete metrics details.

== Best Practices

=== Pattern Design

1. **Be Specific**: Use anchors (`^`, `$`) to avoid over-matching
2. **Test Patterns**: Validate regex patterns before deployment
3. **Order Matters**: More specific patterns should be checked first
4. **Escape Special Characters**: Properly escape dots and other regex metacharacters

.Good Pattern Examples
[source]
----
# Match example.com and all subdomains
^.*\.example\.com$

# Match only staging subdomains
^.*\.staging\.example\.com$

# Match specific service patterns
^svc-[a-z0-9]+\.prod\.company\.com$
----

.Bad Pattern Examples
[source]
----
# Too broad (matches example.com.malicious.com)
example.com

# Unescaped dots match any character
.*example.com.*

# No anchors, could match middle of domain
myservice
----

=== Performance Optimization

1. **Use CoreDNS Cache**: Cache responses at CoreDNS level (30-300s TTL)
2. **Limit Patterns**: Too many patterns increase matching overhead
3. **Pre-compile Patterns**: Patterns are compiled at startup (done automatically)
4. **Monitor Metrics**: Watch for slow queries and adjust patterns

=== Debugging

Enable debug logging to see routing decisions:

[source,bash]
----
# Enable debug mode
DEBUG=true

# Watch for pattern matches
LOG_REQUESTS=true
LOG_RESPONSES=true
----

Example debug output:
[source]
----
[REQUEST] protocol=udp type=A name=app.example.com. from=10.0.1.5:12345
[DEBUG] REQUEST_PATTERN matched: pattern=".*\.example\.com$" request="app.example.com"
[DEBUG] Queried nameserver: explicit
[DEBUG] CNAME_PATTERN matched: pattern=".*\.cdn\.example\.com$" cname="app.cdn.example.com"
[RESPONSE] name=app.example.com. rcode=NOERROR answers=2 resolver=explicit duration=45.2ms
[DEBUG] Full response: ;; opcode: QUERY, status: NOERROR...
----
